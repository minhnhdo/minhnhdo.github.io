<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Theory of Computation - MrOrdinaire</title>
        <link rel="stylesheet" type="text/css" href="../../css/site.css" />
    </head>
    <body>
        <div id="header-strip">
            <div id="header">
                <div id="logo">
                    <a href="../../">MrOrdinaire</a>
                    <span>Programming and other stuff</span>
                </div>
                <div id="navigation">
                    <a href="../../resume.pdf">Résumé</a>
                    <a href="../../notes.html">Notes</a>
                    <a href="../../posts/">Posts</a>
                    <a href="https://twitter.com/mrordinaire">Twitter</a>
                    <a href="https://github.com/mrordinaire">GitHub</a>
                </div>
            </div>
        </div>

        <div id="container">
            <div id="content">
                <h1>Theory of Computation</h1>

                
<h1 id="prerequisite-definitions">Prerequisite Definitions</h1>
<p><em>Alphabets</em> <span class="math inline"><em>Σ</em></span>, and <span class="math inline"><em>Γ</em></span> are finite nonempty sets of symbols.</p>
<p>A <em>string</em> is a finite sequence of zero or more symbols from an alphabet.</p>
<p><span class="math inline"><em>Σ</em><sup>⋆</sup></span> is the set of all strings over alphabet <span class="math inline"><em>Σ</em></span>.</p>
<p><span class="math inline"><em>ϵ</em></span> is the empty string and cannot be in <span class="math inline"><em>Σ</em></span>.</p>
<p>A <em>problem</em> is a mapping from strings to strings.</p>
<p>A <em>decision problem</em> is a problem whose output is yes/no (or often accept/reject).</p>
<p>A decision problem be thought of as the set of all strings for which the function outputs “accept”.</p>
<p>A <em>language</em> is a set of strings, so any set <span class="math inline"><em>S</em> ⊆ <em>Σ</em><sup>⋆</sup></span> is a language, even <span class="math inline">∅</span>. Thus, decision problems are equivalent to languages.</p>
<h1 id="regular-languages">Regular Languages</h1>
<p><span class="math inline"><em>L</em>(<em>M</em>)</span> is the language accepted by machine <span class="math inline"><em>M</em></span>.</p>
<p>A deterministic finite automaton is a 5-tuple <span class="math inline"><em>M</em> = (<em>Q</em>, <em>Σ</em>, <em>δ</em>, <em>q</em><sub>0</sub>, <em>F</em>)</span>, where</p>
<ul>
<li><p><span class="math inline"><em>Q</em></span> is a finite set of states,</p></li>
<li><p><span class="math inline"><em>Σ</em></span> is an alphabet,</p></li>
<li><p><span class="math inline"><em>δ</em> : <em>Q</em> × <em>Σ</em> → <em>Q</em></span> is a transition function describing its transitions and labels,</p></li>
<li><p><span class="math inline"><em>q</em><sub>0</sub> ∈ <em>Q</em></span> is the starting state, and</p></li>
<li><p><span class="math inline"><em>F</em> ⊆ <em>Q</em></span> is a set of accepting states.</p></li>
</ul>
<p>If <span class="math inline"><em>δ</em></span> is not fully specified, we assume an implicit transition to an <em>error state</em>.</p>
<p>A deterministic finite automaton <span class="math inline"><em>M</em></span> accepts input string <span class="math inline"><em>w</em> = <em>w</em><sub>1</sub><em>w</em><sub>2</sub>…<em>w</em><sub><em>n</em></sub></span> (<span class="math inline"><em>w</em><sub><em>i</em></sub> ∈ <em>Σ</em><sup>⋆</sup></span>) if there exists a sequence of states <span class="math inline"><em>r</em><sub>0</sub>, <em>r</em><sub>1</sub>, <em>r</em><sub>2</sub>, …, <em>r</em><sub><em>n</em></sub></span> (<span class="math inline"><em>r</em><sub><em>i</em></sub> ∈ <em>Q</em></span>) such that</p>
<ul>
<li><p><span class="math inline"><em>r</em><sub>0</sub> = <em>q</em><sub>0</sub></span>,</p></li>
<li><p>for all <span class="math inline"><em>i</em> ∈ {1, …, <em>n</em>}</span>, <span class="math inline"><em>r</em><sub><em>i</em></sub> = <em>δ</em>(<em>r</em><sub><em>i</em> − 1</sub>, <em>w</em><sub><em>i</em></sub>)</span>, and</p></li>
<li><p><span class="math inline"><em>r</em><sub><em>n</em></sub> ∈ <em>F</em></span>.</p></li>
</ul>
<p><span class="math inline"><em>r</em><sub>0</sub>, <em>r</em><sub>1</sub>, <em>r</em><sub>2</sub>, …, <em>r</em><sub><em>n</em></sub></span> are the sequence of states visited during the machine’s computation.</p>
<p>A non-deterministic finite automaton is a 5-tuple <span class="math inline"><em>M</em> = (<em>Q</em>, <em>Σ</em>, <em>δ</em>, <em>q</em><sub>0</sub>, <em>F</em>)</span>, where</p>
<ul>
<li><p><span class="math inline"><em>Q</em>, <em>Σ</em>, <em>q</em><sub>0</sub>, <em>F</em></span> are the same as a deterministic finite automaton’s, and</p></li>
<li><p><span class="math inline"><em>δ</em> : <em>Q</em> × (<em>Σ</em> ∪ {<em>ϵ</em>}) → 2<sup><em>Q</em></sup></span>.</p></li>
</ul>
<p>A non-deterministic finite automaton accepts the string <span class="math inline"><em>w</em> = <em>w</em><sub>1</sub><em>w</em><sub>2</sub>…<em>w</em><sub><em>n</em></sub></span> (<span class="math inline"><em>w</em><sub><em>i</em></sub> ∈ <em>Σ</em><sup>⋆</sup></span>) if there exist a string <span class="math inline"><em>y</em> = <em>y</em><sub>1</sub><em>y</em><sub>2</sub>…<em>y</em><sub><em>m</em></sub></span> (<span class="math inline"><em>y</em><sub><em>i</em></sub> ∈ (<em>Σ</em> ∪ {<em>ϵ</em>})<sup>⋆</sup></span>) and a sequence <span class="math inline"><em>r</em> = <em>r</em><sub>0</sub>, <em>r</em><sub>1</sub>, …, <em>r</em><sub><em>n</em></sub></span> (<span class="math inline"><em>r</em><sub><em>i</em></sub> ∈ <em>Q</em></span>) such that</p>
<ul>
<li><p><span class="math inline"><em>w</em> = <em>y</em><sub>1</sub> ∘ <em>y</em><sub>2</sub> ∘ ⋯ ∘ <em>y</em><sub><em>m</em></sub></span> (i.e. <span class="math inline"><em>y</em></span> is <span class="math inline"><em>w</em></span> with some <span class="math inline"><em>ϵ</em></span> inserted),</p></li>
<li><p><span class="math inline"><em>r</em><sub>0</sub> = <em>q</em><sub>0</sub></span>,</p></li>
<li><p>for all <span class="math inline"><em>i</em> = {1, …, <em>m</em>}</span>, <span class="math inline"><em>r</em><sub><em>i</em></sub> ∈ <em>δ</em>(<em>r</em><sub><em>i</em> − 1</sub>, <em>q</em><sub><em>i</em></sub>)</span>, and</p></li>
<li><p><span class="math inline"><em>r</em><sub><em>m</em></sub> ∈ <em>F</em></span>.</p></li>
</ul>
<p>The <em><span class="math inline"><em>ϵ</em></span>-closure</em> for any set <span class="math inline"><em>S</em> ⊆ <em>Q</em></span> is denoted <span class="math inline"><em>E</em>(<em>S</em>)</span>, which is the set of all states in <span class="math inline"><em>Q</em></span> that can be reachable by following any number of <span class="math inline"><em>ϵ</em></span>-transition.</p>
<p>A non-deterministic finite automaton can be converted to an equivalent deterministic finite automaton.</p>
<p>A <em>regular language</em> is any language accepted by some finite automaton. The set of all regular languages is called the <em>class of regular languages</em>.</p>
<p>Regular languages are closed under</p>
<ul>
<li><p>Concatenation <span class="math inline"><em>L</em><sub>1</sub> ∘ <em>L</em><sub>2</sub> = {<em>x</em> ∘ <em>y</em> : <em>x</em> ∈ <em>L</em><sub>1</sub> and <em>y</em> ∈ <em>L</em><sub>2</sub>}</span>. Note: <span class="math inline"><em>L</em><sub>1</sub> ⊈ <em>L</em><sub>1</sub> ∘ <em>L</em><sub>2</sub></span>.</p></li>
<li><p>Union <span class="math inline"><em>L</em><sub>1</sub> ∪ <em>L</em><sub>2</sub> = {<em>x</em> : <em>x</em> ∈ <em>L</em><sub>1</sub> or <em>x</em> ∈ <em>L</em><sub>2</sub>}</span>.</p></li>
<li><p>Intersection <span class="math inline"><em>L</em><sub>1</sub> ∩ <em>L</em><sub>2</sub> = {<em>x</em> : <em>x</em> ∈ <em>L</em><sub>1</sub> and <em>x</em> ∈ <em>L</em><sub>2</sub>}</span>.</p></li>
<li><p>Complement <span class="math inline">$\overline{L} = \Sigma^\star \setminus L = \{x : x \notin L\}$</span>.</p></li>
<li><p>Star <span class="math inline"><em>L</em><sup>⋆</sup> = {<em>x</em><sub>1</sub> ∘ <em>x</em><sub>2</sub> ∘ ⋯ ∘ <em>x</em><sub><em>k</em></sub> : <em>x</em><sub><em>i</em></sub> ∈ <em>L</em> and <em>k</em> ≥ 0}</span>.</p></li>
</ul>
<p><span class="math inline"><em>R</em></span> is a regular expression if <span class="math inline"><em>R</em></span> is</p>
<ul>
<li><p><span class="math inline"><em>a</em> ∈ <em>Σ</em></span>,</p></li>
<li><p><span class="math inline"><em>ϵ</em></span>,</p></li>
<li><p><span class="math inline">∅</span>,</p></li>
<li><p><span class="math inline"><em>R</em><sub>1</sub> ∪ <em>R</em><sub>2</sub></span>, or <span class="math inline"><em>R</em><sub>1</sub>|<em>R</em><sub>2</sub></span>,</p></li>
<li><p><span class="math inline"><em>R</em><sub>1</sub> ∘ <em>R</em><sub>2</sub></span>, or <span class="math inline"><em>R</em><sub>1</sub><em>R</em><sub>2</sub></span>,</p></li>
<li><p><span class="math inline"><em>R</em><sub>1</sub><sup>⋆</sup></span>,</p></li>
<li><p>Shorthand: <span class="math inline"><em>Σ</em> = (<em>a</em><sub>1</sub>|<em>a</em><sub>2</sub>|…|<em>a</em><sub><em>k</em></sub>)</span>, <span class="math inline"><em>a</em><sub><em>i</em></sub> ∈ <em>Σ</em></span>,</p></li>
</ul>
<p>where <span class="math inline"><em>R</em><sub><em>i</em></sub></span> is a regular expression.</p>
<p>Identities of Regular Languages</p>
<ul>
<li><p><span class="math inline">∅ ∪ <em>R</em> = <em>R</em> ∪ ∅ = <em>R</em></span></p></li>
<li><p><span class="math inline">∅ ∘ <em>R</em> = <em>R</em> ∘ ∅ = ∅</span></p></li>
<li><p><span class="math inline"><em>ϵ</em> ∘ <em>R</em> = <em>R</em> ∘ <em>ϵ</em> = <em>R</em></span></p></li>
<li><p><span class="math inline"><em>ϵ</em><sup>⋆</sup> = <em>ϵ</em></span></p></li>
<li><p><span class="math inline">∅<sup>⋆</sup> = ∅</span></p></li>
<li><p><span class="math inline">∅ ∪ <em>R</em> ∘ <em>R</em><sup>⋆</sup> = <em>R</em> ∘ <em>R</em><sup>⋆</sup> ∪ <em>ϵ</em> = <em>R</em><sup>⋆</sup></span></p></li>
<li><p><span class="math inline">(<em>a</em>|<em>b</em>)<sup>⋆</sup> = (<em>a</em><sup>⋆</sup>|<em>b</em><sup>⋆</sup>)<sup>⋆</sup> = (<em>a</em><sup>⋆</sup><em>b</em><sup>⋆</sup>)<sup>⋆</sup> = (<em>a</em><sup>⋆</sup>|<em>b</em>)<sup>⋆</sup> = (<em>a</em>|<em>b</em><sup>⋆</sup>)<sup>⋆</sup> = <em>a</em><sup>⋆</sup>(<em>b</em><em>a</em><sup>⋆</sup>)<sup>⋆</sup> = <em>b</em><sup>⋆</sup>(<em>a</em><em>b</em><sup>⋆</sup>)<sup>⋆</sup></span></p></li>
</ul>
<p>Languages accepted by DFAs = languages accepted by NFAs = regular languages</p>
<p>If <span class="math inline"><em>L</em></span> is a finite language, <span class="math inline"><em>L</em></span> is regular.</p>
<p>If a computation path of any finite automaton is longer than the number of states it has, there must be a cycle in that computation path.</p>
<p>Every regular language satisfies the pumping condition.</p>
<p><em>Pumping condition</em>: There exists an integer <span class="math inline"><em>p</em></span> such that for every string <span class="math inline"><em>w</em> ∈ <em>L</em></span>, with <span class="math inline">|<em>w</em>| ≥ <em>p</em></span>, there exist strings <span class="math inline"><em>x</em>, <em>y</em>, <em>z</em> ∈ <em>Σ</em><sup>⋆</sup></span> with <span class="math inline"><em>w</em> = <em>x</em><em>y</em><em>z</em>, <em>y</em> ≠ <em>ϵ</em>, |<em>x</em><em>y</em>| ≤ <em>p</em></span> such that for all <span class="math inline"><em>i</em> ≥ 0</span>, <span class="math inline"><em>x</em><em>y</em><sup><em>i</em></sup><em>z</em> ∈ <em>L</em></span>.</p>
<p><em>Negation of pumping condition</em>: For all integers <span class="math inline"><em>p</em></span>, there exists a string <span class="math inline"><em>w</em> ∈ <em>L</em></span>, with <span class="math inline">|<em>w</em>| ≥ <em>p</em></span>, for all <span class="math inline"><em>x</em>, <em>y</em>, <em>z</em> ∈ <em>Σ</em><sup>⋆</sup></span> with <span class="math inline"><em>w</em> = <em>x</em><em>y</em><em>z</em>, <em>y</em> ≠ <em>ϵ</em>, |<em>x</em><em>y</em>| ≤ <em>p</em></span>, there exists <span class="math inline"><em>i</em> ≥ 0, <em>i</em> ≠ 1</span> such that <span class="math inline"><em>x</em><em>y</em><sup><em>i</em></sup><em>z</em> ∉ <em>L</em></span>.</p>
<p>Limitations of finite automata:</p>
<ul>
<li><p>Only read input once, left to right.</p></li>
<li><p>Only finite memory.</p></li>
</ul>
<h1 id="context-free-languages">Context-Free Languages</h1>
<p>A pushdown automaton is a 6-tuple <span class="math inline"><em>M</em> = (<em>Q</em>, <em>Σ</em>, <em>Γ</em>, <em>δ</em>, <em>q</em><sub>0</sub>, <em>F</em>)</span>, where</p>
<ul>
<li><p><span class="math inline"><em>Q</em></span> is a finite set of states,</p></li>
<li><p><span class="math inline"><em>Σ</em></span> is its input alphabet,</p></li>
<li><p><span class="math inline"><em>Γ</em></span> is its stack alphabet,</p></li>
<li><p><span class="math inline"><em>δ</em> : <em>Q</em> × (<em>Σ</em> ∪ {<em>ϵ</em>}) × (<em>Γ</em> ∪ {<em>ϵ</em>}) → 2<sup><em>Q</em> × (<em>Γ</em> ∪ <em>ϵ</em>)</sup></span> is its transition function,</p></li>
<li><p><span class="math inline"><em>q</em><sub>0</sub> ∈ <em>Q</em></span> is its starting state, and</p></li>
<li><p><span class="math inline"><em>F</em> ⊆ <em>Q</em></span> is a finite set of accepting states.</p></li>
</ul>
<p>Labels: <span class="math inline"><em>a</em>, <em>b</em> → <em>c</em></span>: if input symbol is <span class="math inline"><em>a</em></span>, and top of stack is <span class="math inline"><em>b</em></span>, pop it and push <span class="math inline"><em>c</em></span>. In other words, input symbol read, stack symbol popped <span class="math inline">→</span> stack symbol pushed, e.g. <span class="math inline">0, <em>ϵ</em> → $</span>.</p>
<p>Suppose <span class="math inline"><em>u</em>, <em>v</em>, <em>w</em></span> are strings of variables and terminals, and there is a rule <span class="math inline"><em>A</em> → <em>w</em></span>. From the string <span class="math inline"><em>u</em><em>A</em><em>v</em></span>, we can obtain <span class="math inline"><em>u</em><em>w</em><em>v</em></span>. We write <span class="math inline"><em>u</em><em>A</em><em>v</em> → <em>u</em><em>w</em><em>v</em></span>, and say <span class="math inline"><em>u</em><em>A</em><em>v</em></span> yields <span class="math inline"><em>u</em><em>w</em><em>v</em></span>.</p>
<p>If <span class="math inline"><em>u</em><sub>1</sub> → <em>u</em><sub>2</sub> → … → <em>u</em><sub><em>k</em></sub></span>, then <span class="math inline"><em>u</em><sub>1</sub>→<sup>⋆</sup><em>u</em><sub><em>k</em></sub></span>, or <span class="math inline"><em>u</em><sub>1</sub></span> derives <span class="math inline"><em>u</em><sub><em>k</em></sub></span>. There must be a finite number of arrows between <span class="math inline"><em>u</em><sub>1</sub></span> and <span class="math inline"><em>u</em><sub><em>k</em></sub></span>.</p>
<p>Given a grammar <span class="math inline"><em>G</em></span>, the language derived by the grammar is <span class="math inline"><em>L</em>(<em>G</em>) = {<em>w</em> ∈ <em>Σ</em><sup>⋆</sup> : <em>S</em>→<sup>⋆</sup><em>w</em> and <em>S</em> is the start variable}</span></p>
<p><em>Context-free grammar:</em> the lhs of rules is a single variable, rhs is any string of variables and terminals. A <em>context-free language</em> is one that can be derived from a context-free grammar. An example context-free grammar is <span class="math inline"><em>G</em> = (<em>V</em>, <em>Σ</em>, <em>R</em>, ⟨<code>EXPR</code>⟩)</span>, where <span class="math inline"><em>V</em> = {⟨<code>EXPR</code>⟩, ⟨<code>TERM</code>⟩, ⟨<code>FACTOR</code>⟩}</span>, <span class="math inline"><em>Σ</em> = {<em>a</em>, +,×,(,)}</span>, and <span class="math inline"><em>R</em> = {⟨<code>EXPR</code>⟩ → ⟨<code>EXPR</code>⟩ + ⟨<code>TERM</code>⟩|⟨<code>TERM</code>⟩, ⟨<code>TERM</code>⟩ → ⟨<code>TERM</code>⟩ × ⟨<code>FACTOR</code>⟩|⟨<code>FACTOR</code>⟩, ⟨<code>FACTOR</code>⟩ → (⟨<code>EXPR</code>⟩)}</span>.</p>
<p>A <em>left-most derivation</em> is a sequence <span class="math inline"><em>S</em> → <em>u</em><sub>1</sub> → <em>u</em><sub>2</sub> → … → <em>u</em><sub><em>k</em></sub> → <em>w</em></span> where each step applies a rule to the left-most variable. A grammar is <em>ambiguous</em> when it has multiple left-most derivations for the same string.</p>
<p>A language <span class="math inline"><em>L</em></span> is recognized by a pushdown automaton iff <span class="math inline"><em>L</em></span> is described by a context-free grammar.</p>
<p>Context-free languages are closed under union, concatenation, star.</p>
<h1 id="recognizable-languages">Recognizable Languages</h1>
<p>Differences from previous models</p>
<ul>
<li><p>The input is written on tape.</p></li>
<li><p>It can write to the tape.</p></li>
<li><p>It can move left and right on tape.</p></li>
<li><p>It halts immediately when it reaches an accepting or rejecting state. The rejecting state must exist but may not be shown.</p></li>
</ul>
<p>A deterministic Turing machine is a 7-tuple <span class="math inline"><em>M</em> = (<em>Q</em>, <em>Σ</em>, <em>Γ</em>, <em>δ</em>, <em>q</em><sub>0</sub>, <em>q</em><sub><em>a</em><em>c</em><em>c</em><em>e</em><em>p</em><em>t</em></sub>, <em>q</em><sub><em>r</em><em>e</em><em>j</em><em>e</em><em>c</em><em>t</em></sub>)</span>, where</p>
<ul>
<li><p><span class="math inline"><em>Q</em></span> is its finite non-empty set of states,</p></li>
<li><p><span class="math inline"><em>Σ</em></span> is its input alphabet,</p></li>
<li><p><span class="math inline"><em>Γ</em></span> is its tape alphabet (<span class="math inline"><em>Σ</em> ⊂ <em>Γ</em></span> and <span class="math inline">$\text{\textvisiblespace } \in \Gamma \setminus \Sigma$</span>),</p></li>
<li><p><span class="math inline"><em>δ</em> : <em>Q</em> × <em>Γ</em> → <em>Q</em> × <em>Γ</em> × {<em>L</em>, <em>R</em>}</span> is its transition function,</p></li>
<li><p><span class="math inline"><em>q</em><sub>0</sub> ∈ <em>Q</em></span> is its starting state,</p></li>
<li><p><span class="math inline"><em>q</em><sub><em>a</em><em>c</em><em>c</em><em>e</em><em>p</em><em>t</em></sub> ∈ <em>Q</em></span> is its accepting state, and</p></li>
<li><p><span class="math inline"><em>q</em><sub><em>r</em><em>e</em><em>j</em><em>e</em><em>c</em><em>t</em></sub> ∈ <em>Q</em></span> is its rejecting state (<span class="math inline"><em>q</em><sub><em>r</em><em>e</em><em>j</em><em>e</em><em>c</em><em>t</em></sub> ≠ <em>q</em><sub><em>a</em><em>c</em><em>c</em><em>e</em><em>p</em><em>t</em></sub></span>).</p></li>
</ul>
<p>Labels: <span class="math inline"><em>a</em> → <em>b</em>, <em>R</em></span>: if tape symbol is <span class="math inline"><em>a</em></span>, write <span class="math inline"><em>b</em></span> and move head right. <span class="math inline"><em>a</em> → <em>R</em></span>: if tape symbol is <span class="math inline"><em>a</em></span>, move head right. <span class="math inline"><em>a</em>, <em>b</em>, <em>c</em> → <em>R</em></span>: if tape symbol is <span class="math inline"><em>a</em>, <em>b</em></span>, or <span class="math inline"><em>c</em></span>, move head right.</p>
<p>On input <span class="math inline"><em>x</em></span>, a Turing machine can (1) accept, (2) reject, or (3) run in an infinite loop.</p>
<p>The language <em>recognized</em> by a Turing machine <span class="math inline"><em>M</em></span> is <span class="math inline"><em>L</em>(<em>M</em>) = {<em>x</em> : on input <em>x</em>, <em>M</em> halts in <em>q</em><sub><em>a</em><em>c</em><em>c</em><em>e</em><em>p</em><em>t</em></sub>}</span>. A language is <em>recognizable</em> if there exists a Turing machine which recognizes it.</p>
<p>Regular languages <span class="math inline">⊆</span> context-free languages <span class="math inline">⊆</span> decidable languages <span class="math inline">⊆</span> recognizable languages</p>
<p>A <em>configuration</em> is a way to describe the entire state of the Turing machine. It is a string <span class="math inline"><em>a</em><em>q</em><em>b</em></span> where <span class="math inline"><em>a</em> ∈ <em>Γ</em><sup>⋆</sup>, <em>q</em> ∈ <em>Q</em>, <em>b</em> ∈ <em>Γ</em><sup>⋆</sup></span>, which indicates that <span class="math inline"><em>q</em></span> is the current state of the Turing machine, the tape content currently is <span class="math inline"><em>a</em><em>b</em></span> and its head is currently pointing at the first symbol of <span class="math inline"><em>b</em></span>. Any Turing machine halts if its configuration is of the form <span class="math inline"><em>a</em><em>q</em><sub><em>a</em><em>c</em><em>c</em><em>e</em><em>p</em><em>t</em></sub><em>b</em></span>, or <span class="math inline"><em>a</em><em>q</em><sub><em>r</em><em>e</em><em>j</em><em>e</em><em>c</em><em>t</em></sub><em>b</em></span> for any <span class="math inline"><em>a</em><em>b</em></span>. Config(<span class="math inline"><em>i</em></span>) uniquely determines Config(<span class="math inline"><em>i</em> + 1</span>).</p>
<p>Every <span class="math inline"><em>k</em></span>-tape Turing machine has an equivalent single tape Turing machine.</p>
<p>If the alphabet of the multitape Turing machine is <span class="math inline"><em>Γ</em></span>, we can make the single tape Turing machine’s alphabet <span class="math inline">(<em>Γ</em> ∪ {#}) × {<code>normal</code>, <code>bold</code>}</span>.</p>
<p>A non-deterministic Turing machine is a 7-tuple <span class="math inline"><em>M</em> = (<em>Q</em>, <em>Σ</em>, <em>Γ</em>, <em>δ</em>, <em>q</em><sub>0</sub>, <em>q</em><sub><em>a</em><em>c</em><em>c</em><em>e</em><em>p</em><em>t</em></sub>, <em>q</em><sub><em>r</em><em>e</em><em>j</em><em>e</em><em>c</em><em>t</em></sub>)</span>, where the only difference from a deterministic Turing machine is the transition function <span class="math inline"><em>d</em><em>e</em><em>l</em><em>t</em><em>a</em> : <em>Q</em> × <em>Γ</em> → 2<sup><em>Q</em> × <em>Γ</em> × {<em>L</em>, <em>R</em>}</sup></span>.</p>
<p>A non-deterministic Turing machine accepts its input iff some node in the configuration tree has <span class="math inline"><em>q</em><sub><em>a</em><em>c</em><em>c</em><em>e</em><em>p</em><em>t</em></sub></span>. It does not accept its input iff the configuration tree grows forever (infinite loop) or no node in the tree has <span class="math inline"><em>q</em><sub><em>a</em><em>c</em><em>c</em><em>e</em><em>p</em><em>t</em></sub></span>.</p>
<p><em>Acceptance of a non-deterministic Turing machine:</em> input <span class="math inline"><em>w</em></span> is accepted if there exist configurations <span class="math inline"><em>c</em><sub>0</sub>, <em>c</em><sub>1</sub>, …, <em>c</em><sub><em>k</em></sub></span> where</p>
<ul>
<li><p><span class="math inline"><em>c</em><sub>0</sub> = <em>q</em><sub><em>s</em><em>t</em><em>a</em><em>r</em><em>t</em></sub><em>w</em></span>, and</p></li>
<li><p><span class="math inline"><em>c</em><sub><em>i</em></sub> ⇒ <em>c</em><sub><em>i</em> + 1</sub></span> (<span class="math inline"><em>c</em><sub><em>i</em> + 1</sub></span> is a possible configuration from <span class="math inline"><em>c</em><sub><em>i</em></sub></span>, following the transition function <span class="math inline"><em>δ</em></span>).</p></li>
</ul>
<p>The outcomes could be</p>
<ul>
<li><p><span class="math inline"><em>w</em></span> is accepted, i.e. there exists a node in the tree which is an accepting configuration,</p></li>
<li><p><span class="math inline"><em>w</em></span> is explicitly rejected, i.e. the tree is finite but no node is an accepting configuration (all leaves are rejecting configurations), or</p></li>
<li><p>the non-deterministic Turing machine runs forever on <span class="math inline"><em>w</em></span>, i.e. the tree is infinite but no node is an accepting configuration (there might be finite branches terminating in a rejecting configuration in the tree).</p></li>
</ul>
<p>A Turing machien is a <em>decider</em> if it halts on all inputs, i.e. it either rejects or accepts all inputs.</p>
<p>Every non-deterministic Turing machine has an equivalent deterministic Turing machine. If that non-deterministic Turing machine is a decider, there is an equivalent deterministic Turing machine decider.</p>
<p>Recognizable languages are closed under union, intersection, concatenation, star.</p>
<p>Implementation level description of a multitape Turing machine for <span class="math inline"><em>L</em> = {<em>x</em>#<em>x</em> : <em>x</em> ∈ {0, 1}<sup>⋆</sup>}</span>:</p>
<ul>
<li><p>Scan the first head to the right until it reads a <span class="math inline">#</span>. Move right. The second head is still at the start of the second tape.</p></li>
<li><p>Repeatedly read symbol from the first tape (reject if the symbol is not <span class="math inline">0</span> or <span class="math inline">1</span>), write it to the second tape, and move both heads right, until seeing a blank on the first tape.</p></li>
<li><p>Move the first head left until a <span class="math inline">#</span> is under it. Replace the symbol with a blank ().</p></li>
<li><p>Move both heads left until they reach the start of their respective tapes (using the <span class="math inline">$</span> sign hack to mark the start of the tape).</p></li>
<li><p>Repeat until seeing a blank on both tapes.</p>
<ul>
<li><p>If the symbols on the two tapes differ, reject.</p></li>
<li><p>Otherwise, move both head right.</p></li>
</ul></li>
</ul>
<p><span class="math inline">⟨<em>O</em>⟩</span> is a string encoding for the object <span class="math inline"><em>O</em></span>.</p>
<p><em>Cardinality of Sets:</em> two sets <span class="math inline"><em>A</em></span> and <span class="math inline"><em>B</em></span> have the same <em>cardinality</em> if there exists a bijection <span class="math inline"><em>f</em> : <em>A</em> → <em>B</em></span>.</p>
<p><span class="math inline">ℕ = {1, 2, 3, …}</span> is the set of all natural numbers. A set is <em>finite</em> if it has a bijection to {1..n} for some natural number <span class="math inline"><em>n</em></span>. A set is <em>countably infinite</em> if it has the same cardinality as <span class="math inline">ℕ</span>. A set is <em>countable</em> or <em>at most countable</em> if it is finite or countably infinite.</p>
<p>Any language <span class="math inline"><em>L</em></span> is countable.</p>
<p>The set of all Turing machines is countable.</p>
<p>The set <span class="math inline">ℬ</span> of all infinite bit-sequences is not countable.</p>
<p><span class="math inline">2<sup><em>Σ</em><sup>⋆</sup></sup></span> is uncountable.</p>
<p><span class="math inline"><em>A</em><sub><em>T</em><em>M</em></sub> = {⟨<em>M</em>, <em>w</em>⟩ : <em>M</em> accepts <em>w</em>}</span> is recognizable but not decidable.</p>

            </div>
        </div>
        <div id="footer-strip">
            <div id="footer">
                Site proudly generated by
                <a href="http://jaspervdj.be/hakyll/">Hakyll</a>
                and
                <a href="http://fvisser.nl/clay/">Clay</a>
                <br />
                with
                <a href="http://ethanschoonover.com/solarized">Solarized</a>
                color scheme.
            </div>
        </div>
    </body>
</html>
