<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Theory of Computing - Minh Do</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="stylesheet" href="../../../css/site.css" type="text/css" />
        <link href="http://fonts.googleapis.com/css?family=Lato|PT+Sans:400,400italic,700|Inconsolata" rel="stylesheet" type="text/css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
        <script src="//minhdo.disqus.com/embed.js" async></script>
    </head>
    <body>
        <header>
            <div id="logo">
                <a href="../../../">Minh Do</a>
            </div>
            <div id="navigation">
                <a href="../../../resume.pdf">Résumé</a>
                <a href="../../../posts/">Posts</a>
                <a href="../../../notes/">Notes</a>
                <a href="https://github.com/minhnhdo">Code</a>
            </div>
        </header>

        <article>
            <h1>Theory of Computing</h1>
            
            <p id="subtitle">Finite Automata</p>
            

            <h1 id="finite-automata">Finite automata</h1>
<h2 id="why">Why?</h2>
<p>To study the languages related to FAs</p>
<ol type="1">
<li>as a stepping stone to a richer computational model</li>
<li>useful background for NLP and compilers</li>
<li>understand regexp</li>
</ol>
<h2 id="informal-definition-for-computational-machines">Informal definition for computational machines</h2>
<dl>
<dt>Computational machine (informal)</dt>
<dd><p>Fix an alphabet Σ; a computational machine M for a decision problem on any input string ω ∈ Σ*, either</p>
<ol type="1">
<li>outputs Accept and halt</li>
<li>outputs Reject and halt</li>
<li>run forever</li>
</ol>
</dd>
</dl>
<h2 id="deterministic-finite-automata">Deterministic finite automata</h2>
<dl>
<dt>Deterministic finite automaton</dt>
<dd><p>a deterministic finite automaton is a 5-tuple M = (Q, Σ, δ, q₀, F) where</p>
<ol type="1">
<li>Q is a finite set of states</li>
<li>Σ is a finite set (the alphabet)</li>
<li>δ : Q × Σ → Q (the transition function, which describes the transition and labels).</li>
<li>q₀ ∈ Q (starting state)</li>
<li>F ⊆ Q (accepting states)</li>
</ol>
</dd>
</dl>
<h3 id="acceptance">Acceptance</h3>
<p>A finite automaton M accepts intput string ω = ω₁ω₂…ωₙ ∈ Σ* if there exists a sequence of states r₀,r₁,…,rₙ ∈ Q such that</p>
<ul>
<li>r₀ = q₀</li>
<li>rᵢ = δ(r<sub>i-1</sub>, ωᵢ) ∀i = 1..n</li>
<li>rₙ ∈ F</li>
</ul>
<p>r₀,r₁,…,rₙ are the sequence of states visited during the machine’s computation.</p>
<p>L(M) = { ω ∈ Σ* : M accepts ω }, the language accepted/decided/recognized by M.</p>
<h3 id="implicit-error-states">Implicit error states</h3>
<p>If δ is not fully specified, we assume an implicit transition to en error state.</p>
<h2 id="non-deterministic-finite-automata">Non-deterministic finite automata</h2>
<dl>
<dt>Non-deterministic finite automaton</dt>
<dd><p>a non-deterministic finite automaton is a 5-tuple M = (Q, Σ, δ, q₀, F), where</p>
<ol type="1">
<li>Q, Σ, q₀, and F are the same as DFA’s</li>
<li>δ : q × (Σ ∪ {ε}) → 2<sup>Q</sup></li>
</ol>
</dd>
</dl>
<p>Observation: ε is the empty string and cannot be in Σ.</p>
<h3 id="acceptance-1">Acceptance</h3>
<p>An NFA accepts the string ω = ω₁ω₂…ωₙ if there exists a string y = y₁y₂…yₙ, where yᵢ ∈ Σ ∪ {ε} and a sequence r = r₀,r₁,..,rₘ, where rᵢ ∈ Q such that</p>
<ul>
<li>ω = y₁ ∘ y₂ ∘ … ∘ yₘ, i.e. y is ω with some ε inserted</li>
<li>r₀ = q₀</li>
<li>rᵢ ∈ δ(r<sub>i-1</sub>, qᵢ) ∀i = 1..m</li>
<li>rₘ ∈ F</li>
</ul>
<h1 id="regular-expressions">Regular expressions</h1>
<p>R is a regular expression if R is any of the following, where R₁ and R₂ are regular expressions.</p>
<ul>
<li>a ∈ Σ</li>
<li>ε (the empty string)</li>
<li>∅ (the empty set)</li>
<li>R₁ ∪ R₂ or R₁ | R₂</li>
<li>R₁ ∘ R₂ or R₁R₂</li>
<li>R₁*</li>
</ul>
<p>Short hand: Σ = (a₁ | a₂ | … | aₖ) where Σ = {a₁, a₂, …, aₖ}.</p>
<p>Notation: L(R) is the set of strings generated by the regular expression R.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">R</th>
<th style="text-align: center;">L(R)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0<em>1</em></td>
<td style="text-align: center;">{ 0ⁱ1ʲ : i, j ≥ 0 }</td>
</tr>
<tr class="even">
<td style="text-align: center;">Σ<em>001Σ</em></td>
<td style="text-align: center;">{ all strings containing 001 as a substring }</td>
</tr>
<tr class="odd">
<td style="text-align: center;">(ΣΣ)*</td>
<td style="text-align: center;">{ all strings of even length }</td>
</tr>
<tr class="even">
<td style="text-align: center;">Σ<em>1Σ</em>1Σ<em>1Σ</em></td>
<td style="text-align: center;">{ ω : ω contains at least three 1’s} }</td>
</tr>
</tbody>
</table>
<h1 id="equivalence-of-dfas-nfas-and-regular-expressions">Equivalence of DFAs, NFAs, and regular expressions</h1>
<p><strong>Theorem:</strong> languages accepted by DFAs = languages accepted by NFAs = languages described by regular expressions = regular languages.</p>
<h1 id="regular-languages">Regular languages</h1>
<dl>
<dt>Regular language</dt>
<dd>a regular language is any language accepted by some FA. The set of all regular languages is called the class of regular languages (i.e. set of sets).
</dd>
</dl>
<p><strong>Theorem:</strong> Regular languages are closed under union, concatenation, Kleene star, and complement.</p>
<h2 id="operations">Operations</h2>
<p>Let L₁ and L₂ be languages.</p>
<dl>
<dt>Concatenation</dt>
<dd>L₁ ∘ L₂ = {x ∘ y : x ∈ L₁ and y ∈ L₂} (note L₁ ⊄ L₁ ∘ L₂)
</dd>
<dt>Union</dt>
<dd>L₁ ∪ L₂ = {x : x ∈ A or x ∈ B}.
</dd>
<dt>Kleene star</dt>
<dd>L₁* = {x₁ ∘ x₂ ∘ … ∘ xₖ : xᵢ ∈ A and k ≥ 0}
</dd>
<dt>Complement</dt>
<dd>Σ  L₁ = {x : x ∉ A}
</dd>
<dt>Intersection</dt>
<dd>L₁ ∩ L₂ = {x : x ∈ A and x ∈ B}
</dd>
</dl>
<p><strong>Theorem (closure properties):</strong> If A and B are regular languages, then so are their concatenation, union, Kleene star, complement, and intersection.</p>
<h2 id="ε-closure">ε closure</h2>
<dl>
<dt>ε closure</dt>
<dd>for any S ⊆ Q, let E(S) be the set of all states in Q that can be reached by following any number of ε-transitions.
</dd>
</dl>
<h1 id="limits-to-the-power-of-finite-automata">Limits to the power of finite automata</h1>
<p>Can any language be described by a finite automaton?</p>
<ul>
<li>Example 1: Suppose L is a finite language. Is L regular?
<ul>
<li>Yes. Suppose L = {x₁, x₂, …, xₙ}. Define Lᵢ = {xᵢ}, which is regular. We know Lᵢ ∪ Lⱼ is regular, so L₁ ∪ L₂ ∪ … ∪ Lₙ is regular.</li>
<li>This construction fails if L is infinite (we’d get an “infinite” automaton).</li>
</ul></li>
<li>Example 2: Suppose L is regular. Is L² = {xy : x ∈ L and y ∈ L} regular?
<ul>
<li>Yes, it is L ∘ L.</li>
</ul></li>
<li>Example 3: Suppose L is regular. Define L<sup>dup</sup> = {xx : x ∈ L}.
<ul>
<li>If L is finite, L<sup>dup</sup> is also finite and hence is regular.</li>
<li>If L = L(1*), then L<sup>dup</sup> = L((11)*), which is regular.</li>
<li>if L = Σ*, L<sup>dup</sup> = {xx : x ∈ Σ*}.
<ul>
<li>Intuitively, {xx : x ∈ Σ*} is not regular.</li>
<li>In a finite automaton, its states are its memory.</li>
<li>Any FA accepting L<sup>dup</sup> must remember the first half to compare it to the second half.</li>
<li>So FA must remember arbitrary large information but it can’t.</li>
</ul></li>
</ul></li>
</ul>
<p>Finite automata can only read input once, from left to right.</p>
<p>They can only have finite memory.</p>
        </article>

        <footer>
            
            <div id="disqus_thread"></div>
            <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
            <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
            

            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll/">Hakyll</a>
            and
            <a href="http://fvisser.nl/clay/">Clay</a>
            <br />
            with
            <a href="http://ethanschoonover.com/solarized">Solarized</a>
            color scheme.
        </footer>
    </body>
</html>
