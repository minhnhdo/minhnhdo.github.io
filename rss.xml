<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"> <channel> <title>MrOrdinaire</title> <link>http://minhdo.org</link> <atom:link href="http://minhdo.org/rss.xml" rel="self" type="application/rss+xml" /> <language>en-us</language> <pubDate>Thu, 18 Apr 2013 15:06:45 GMT</pubDate> <item> <title>Maths and Programs</title> <link>http://minhdo.org/posts/Maths-and-Programs.html</link> <pubDate>2012-10-01 00:00:00</pubDate> <author>Do Nhat Minh</author> <guid isPermaLink="true">http://minhdo.org/posts/Maths-and-Programs.html</guid> <category><![CDATA[ existential quantifiers ]]></category><category><![CDATA[ functional programming ]]></category><category><![CDATA[ universal quantifiers ]]></category> <description><![CDATA[ 

<p>Let's solve this question (taken from the second assignment of <a href="https://www.coursera.org/course/progfun" >Functional Programming in Scala</a>):</p>

<blockquote>
<p>Using <code>forall</code>, implement a function <code>exists</code> which tests whether a set contains at least one element for which the given predicate is true. Note that the functions <code>forall</code> and <code>exists</code> behave like the universal and existential quantifiers of first-order logic.</p>
</blockquote>

<p>The code listing for <code>forall</code> is as follows:</p>

<pre><code>def forall(s: Set, p: Int =&gt; Boolean): Boolean = {
  def iter(a: Int): Boolean = {
    if (a &gt; bound) true
    else if (contains(s, a) &amp;&amp; !p(a)) false
    else iter(a + 1)
  }
  iter(-bound)
}
</code></pre>

<p>where <code>bound</code> is <code>1000</code>.</p>

<p>A set is a defined as follows, along with the predicate to test for containment.</p>

<pre><code>type Set = Int =&gt; Boolean
def contains(s: Set, x: Int) = s(x)
</code></pre>

<p>Here is how I arrive at the answer for the question:</p>

<blockquote>
<ol>
<li>From the question, it is intuitive to try to stop the iteration when there is an element that satisfies the predicate <code>p</code>, which is exactly what <code>exists</code> should do.</li>
<li>The iteration is stopped only when the current element <code>a</code> does not satisfy <code>p</code>.</li>
<li>However, we need to satisfy <code>p</code> in order for <code>exists</code> to correctly do its job.</li>
</ol>

<p>In conclusion, we need a double negation here. In other words, we need to negate <code>p</code> and then negate the answer returned by <code>forall</code> when called with the negation of <code>p</code>.</p>
</blockquote>

<p>From that reasoning, it is easy to code up the first attempt at a solution.</p>

<pre><code>def exists(s: Set, p: Int =&gt; Boolean): Boolean = !forall(s, x =&gt; !p(x))
</code></pre>

<p>Now, let's see how this solution fares.</p>

<pre><code>scala&gt; def natural = (x: Int) =&gt; x &gt; 0
scala&gt; forall(natural, x % 2 == 0) // should return false, as not all naturals are even
Res01 = false
scala&gt; exists(natural, x % 2 == 0) // should return true
Res02 = true
</code></pre>

<p>The solution passes the tests. Let's look at how to explain the code simply. The code says</p>

<blockquote>
<p>There exists in set <code>s</code> an element that satisfies the predicate <code>p</code> when not all of the elements in <code>s</code> satisfies the negation of <code>p</code>.</p>
</blockquote>

<p>That makes sense. But lo and behold, the code reflects a mathematical truth, and it even looks like it is translated verbatim from mathematical symbols to programmatical symbols!</p>

<p>&exist;x:P(x) &equiv; &not;&forall;x:&not;P(x)</p>

<p>compared with</p>

<pre><code>def exists(s: Set, p: Int =&gt; Boolean): Boolean = !forall(s, x =&gt; !p(x))
</code></pre>

<p>The correspondence is remarkable!</p>

<p>After reading this post, you should try this question. The answer will pleasantly surprise you.</p>

<blockquote>
<p>Finally, write a function <code>map</code> which transforms a given set into another one by applying to each of its element the given function. <code>map</code> has the following signature:</p>
</blockquote>

<pre><code>def map(s: Set, f: Int =&gt; Int): Set
</code></pre>
 ]]></description> </item><item> <title>Zen in Gödel, Escher and Bach: An Eternal Golden Braid</title> <link>http://minhdo.org/posts/Zen-in-Gdel-Escher-and-Bach-An-Eternal-Golden-Braid.html</link> <pubDate>2012-09-26 00:00:00</pubDate> <author>Do Nhat Minh</author> <guid isPermaLink="true">http://minhdo.org/posts/Zen-in-Gdel-Escher-and-Bach-An-Eternal-Golden-Braid.html</guid> <category><![CDATA[ excerpt ]]></category><category><![CDATA[ literature ]]></category><category><![CDATA[ philosophy ]]></category><category><![CDATA[ spirituality ]]></category><category><![CDATA[ zen ]]></category> <description><![CDATA[ 

<blockquote>
<p>[...] in general, the Zen attitude is that words and truth are incompatible, or at least that no words can capture truth.</p>
</blockquote>

<p align="right">page 246</p>

<blockquote>
<p>[...] Perhaps the most concise summary of enlightenment would be: trainscending dualism.</p>
</blockquote>

<p align="right">page 251</p>

<blockquote>
<p>[...] it is perhaps wrong to say that the enemy of enlightenment is logic; rather, it is dualistic, verbal thinking. In fact, it is even more basic than that: it is perception. As soon as you perceive an object, you draw a line between it and the rest of the world; you divide the world, artificially, into parts, and you thereby miss the Way.</p>
</blockquote>

<p align="right">page 251</p>

<blockquote>
<p>Zen is holism, carried to its logical extreme. If holism claims that things can only be understood as wholes, not as sums of their parts, Zen goes one further, in maintaining that the world cannot be broken into parts at all. To divide the world into parts is to be deluded, and to miss enlightenment.</p>
</blockquote>

<p align="right">page 254</p>

<blockquote>
<p>Zen is a system and cannot be its own metasystem; there is always something outside of Zen, which cannot be fully understood or described within Zen.</p>
</blockquote>

<p align="right">page 255</p>

<p>Taken from <a href="http://en.wikipedia.org/wiki/G%C3%B6del,_Escher,_Bach" >Gödel, Escher and Bach: An Eternal Golden Braid</a> by <a href="http://en.wikipedia.org/wiki/Douglas_Hofstadter" >Douglas R. Hofstadter</a>.</p>
 ]]></description> </item><item> <title>Setting for NTU MailBox</title> <link>http://minhdo.org/posts/Setting-for-NTU-MailBox.html</link> <pubDate>2012-09-11 00:00:00</pubDate> <author>Do Nhat Minh</author> <guid isPermaLink="true">http://minhdo.org/posts/Setting-for-NTU-MailBox.html</guid> <category><![CDATA[ configuration ]]></category><category><![CDATA[ mailbox ]]></category><category><![CDATA[ ntu ]]></category><category><![CDATA[ setting ]]></category> <description><![CDATA[ <p>External POP setting:</p>

<ul>
<li>Server name: pod51003.outlook.com</li>
<li>Port: 995</li>
<li>Encryption method: SSL</li>
</ul>

<p>External IMAP setting:</p>

<ul>
<li>Server name: pod51003.outlook.com</li>
<li>Port: 993</li>
<li>Encryption method: SSL</li>
</ul>

<p>External SMTP setting:</p>

<ul>
<li>Server name: pod51003.outlook.com</li>
<li>Port: 587</li>
<li>Encryption method: TLS</li>
</ul>

<p>They can be found on the About page of the web app.</p>
 ]]></description> </item> </channel> </rss>
