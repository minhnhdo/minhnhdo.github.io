<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"> <channel> <title>MrOrdinaire</title> <link>http://minhdo.org</link> <atom:link href="http://minhdo.org/rss.xml" rel="self" type="application/rss+xml" /> <language>en-us</language> <pubDate>Thu, 18 Apr 2013 15:30:54 GMT</pubDate> <item> <title>How to set up NTUVPN on Ubuntu</title> <link>http://minhdo.org/posts/How-to-set-up-NTUVPN-on-Ubuntu.html</link> <pubDate>2013-03-06 09:17:00</pubDate> <author>Do Nhat Minh</author> <guid isPermaLink="true">http://minhdo.org/posts/How-to-set-up-NTUVPN-on-Ubuntu.html</guid> <category><![CDATA[ ntu ]]></category><category><![CDATA[ vpn ]]></category><category><![CDATA[ setup ]]></category><category><![CDATA[ ubuntu ]]></category> <description><![CDATA[ 

<p><em>For Ubuntu users, the NTU's <a href="http://www.ntu.edu.sg/cits/itnetworking/remoteaccess/Pages/quickstartguide.aspx#sslvpn" >official instruction</a> to setup a <a href="http://en.wikipedia.org/wiki/Vpn" title="Virtual private network">VPN</a> client requires them to install a java plugin in order to connect to its server. However, the client can only run on a 32-bit JVM, and even if it is running on one, the client seems to hang. Therefore, to save you from all these hassles, this post will help you set up a VPN client that runs natively on Ubuntu.</em></p>

<h2>Installing the required package</h2>

<p>Firstly, you need to install the <a href="http://en.wikipedia.org/wiki/Pptp" >PPTP</a> plugin for Network Manager, which provides a PPTP VPN plugin to connect to a Microsoft VPN server.</p>

<p>Open up your Terminal and type in</p>

<pre><code>sudo apt-get install network-manager-pptp</code></pre>

<p>Enter your password if required and wait until it finishes installing.</p>

<h2>Setting up a VPN connection</h2>

<p>Click on the Network Manager icon, select <code>VPN Connections</code> and choose <code>Configure VPN...</code></p>

<p>In the <code>Choose a VPN Connection Type</code> dialog, select <code>Point-to-Point Tunneling Protocol (PPTP)</code> and click <code>Create</code></p>

<p>In the newly opened dialog, type in the following:</p>

<ul>
<li><code>Connection name:</code> &rarr; <code>NTUVPN</code></li>
<li><code>Gateway:</code> &rarr; <code>vpngate.ntu.edu.sg</code></li>
<li><code>User name:</code> &rarr; your NTU user name, prefixed by <code>STUDENT\</code>, e.g. <code>STUDENT\name1</code></li>
<li><code>Password:</code> &rarr; your password</li>
</ul>

<p>Click on <code>Advanced...</code>, tick <code>Use Point-to-Point encryption (MPPE)</code>, and click <code>OK</code></p>

<p>Finally, click <code>Save...</code></p>

<h2>Connect to NTUVPN</h2>

<p>Click on the Network Manager icon, select <code>VPN Connections</code> and choose the newly created <code>NTUVPN</code>. The connection should be established now.</p>

<h2>Disconnect from NTUVPN</h2>

<p>To disconnect from NTUVPN, click on the Network Manager icon, select <code>VPN Connections</code> and choose <code>Disconnect VPN</code></p>
 ]]></description> </item><item> <title>Hello, JIT World from D</title> <link>http://minhdo.org/posts/Hello-JIT-World-from-D.html</link> <pubDate>2013-01-15 00:00:00</pubDate> <author>Do Nhat Minh</author> <guid isPermaLink="true">http://minhdo.org/posts/Hello-JIT-World-from-D.html</guid> <category><![CDATA[ just-in-time ]]></category><category><![CDATA[ d programming language ]]></category><category><![CDATA[ beginner ]]></category> <description><![CDATA[ 

<p><em>This post is inspired by <a href="http://blog.reverberate.org/2012/12/hello-jit-world-joy-of-simple-jits.html" >Hello, JIT World: The Joy of Simple JITs</a>, especially the first short program that he used to demonstrate that JIT programming can be simple. In this post, I will convert the program he wrote in C to <a href="http://en.wikipedia.org/wiki/D_(programming_language)" >D</a> to show some capabilities and convenience of D.</em></p>

<p>What follows is the whole source of the program in D. You can view the original source in C in the blog post linked above.</p>

<pre><code>import std.c.string;
import std.c.linux.linux;
import std.conv;
import std.stdio;

int main(string[] args)
{
    // Machine code for:
    //   mov eax, 0
    //   ret
    ubyte code[] = [0xb8, 0x00, 0x00, 0x00, 0x00, 0xc3];

    if (args.length < 2)
    {
        stderr.writeln("Usage: jit1 <integer>");
        return 1;
    }

    // Overwrite immediate value "0" in the instruction
    // with the user's value.  This will make our code:
    //   mov eax, <user's value>
    //   ret
    int num = to!int(args[1]);
    memcpy(&code[1], &num, 4);

    // Allocate writable/executable memory.
    // Note: real programs should not map memory both writable
    // and executable because it is a security risk.
    void* mem = mmap(null, code.sizeof, PROT_WRITE | PROT_EXEC,
            MAP_ANON | MAP_PRIVATE, -1, 0);
    memcpy(mem, code, code.sizeof);

    // The function will return the user's value.
    int function() func = cast(int function())mem;
    return func();
}</code></pre>

<p>Let's go through some first impressions.</p>

<p>D programming language is in the same family of languages that have the C flavor, so you might already find the code familiar and quite easy to read. Some familiarities are</p>

<ul>
<li>double forward slashes starts a line comment</li>
</ul>

<pre><code>// a line comment which extends only to the end of the line</code></pre>

<ul>
<li>curly braces around a block of code</li>
</ul>

<pre><code>{
    // block of code
}</code></pre>

<ul>
<li>every statement ends in a semicolon</li>
</ul>

<pre><code>statement; // assuming you have statement defined</code></pre>

<ul>
<li>type goes before the identifier in a declaration</li>
</ul>

<pre><code>int a;
long b;</code></pre>

<ul>
<li>all executions start from the <code>main</code> function which can have one of the following signatures</li>
</ul>

<pre><code>int main();
int main(string[]);
void main();
void main(string[]);</code></pre>

<ul>
<li>and unlike C (or C++ for that matter), the D standard actually have <code>void main(...)</code> functions return 0 (which means success) to the shell.</li>
<li>indexing operator is <code>[]</code></li>
</ul>

<pre><code>int[2] a;
a[1] = 1; // use this to index into the second element of a</code></pre>

<ul>
<li>address-of operator is <code>&amp;</code></li>
</ul>

<pre><code>int a;
int* b = &a;</code></pre>

<ul>
<li>from the above example you can also see that there are pointer types in D and the syntax for declaring one is just like C's</li>
<li>there's actually a <code>null</code> value for pointers, not just a cast from zero as in C</li>
<li>bitwise operators in D are the same as in C, e.g. <code>|</code>, <code>&amp;</code> and <code>~</code></li>
<li>you can cast from one time to another, which is not recommended unless you know exactly what you are doing as the safe subset of D is powerful enough for most applications, by doing</li>
</ul>

<pre><code>void* a;
char* b = cast(char*)a;</code></pre>

<ul>
<li>syntax for returning from a function is</li>
</ul>

<pre><code>return expression; // where expression is any expression, e.g. 1 + 1</code></pre>

<p>So D is quite similar to C/C++. But the differences that set D apart is even more interesting.</p>

<ul>
<li>there is a concept of modules that can <code>import</code> each other, so that a source file does not have to be processed so many times in compilation (well, there's more to this but the reduction in compilation time that comes with this is, to me, the most significant benefit)</li>
<li>string is actually supported, not something that feels bolted on like in C (or C++)</li>
<li>there's no <code>unsigned</code> keyword. Most types have their unsigned counterparts named with a <code>u</code> prepended.</li>
<li>arrays know their own lengths, which can be accessed by doing</li>
</ul>

<pre><code>int[200] a;
writeln(a.length); // assuming you have `import std.stdio;` before this.
// Prints out 200.</code></pre>

<ul>
<li><code>to</code> in <code>to!int</code> is a generic function (and you specialize it using the bang-type syntax). The syntax, though unfamiliar, but greatly simplifies parsing, both for compilers and for humans.</li>
<li>C code can be called directly from D after creating declarations for it. The function <code>memcpy</code> and <code>mmap</code> are C functions whose declarations are defined in packages <code>string</code> and <code>linux</code>.</li>
<li>the size of some variable in bytes can be obtained from doing <code>variable.sizeof</code></li>
<li>any pointer type is automatically convertible to <code>void*</code>, not so for the converse.</li>
<li>there is a <code>function</code> keyword so that the type of a function pointer or complex types can be declared without hurting your brain</li>
</ul>

<pre><code>// fp is a pointer to a function that takes a function taking a char
// returning an int and returns a typeless pointer
// (try saying that five times fast)
void* function(int function(char)) fp;
// the equivalent for that in C is
// void* (*fp)(int (*)(char));

// let's look at something more interesting
// signal is a function that takes an int and a pointer to a function
// taking an int returning nothing and returns a pointer to a function
// taking an int returning nothing
void function(int) signal(int sig, void function(int) func));
// the equivalent for that in C is
// void (*signal (int sig, void (*func)(int)) )(int);
// try reading that five times fast :)</code></pre>

<p>Those are the differences that are present in this code snippet, you can check out more about D at the <a href="http://dlang.org" >D home page</a> or a summary at the <a href="http://en.wikipedia.org/wiki/D_(programming_language)" >wikipedia page</a>.</p>
 ]]></description> </item><item> <title>Maths and Programs</title> <link>http://minhdo.org/posts/Maths-and-Programs.html</link> <pubDate>2012-10-01 00:00:00</pubDate> <author>Do Nhat Minh</author> <guid isPermaLink="true">http://minhdo.org/posts/Maths-and-Programs.html</guid> <category><![CDATA[ existential quantifiers ]]></category><category><![CDATA[ functional programming ]]></category><category><![CDATA[ universal quantifiers ]]></category> <description><![CDATA[ 

<p>Let's solve this question (taken from the second assignment of <a href="https://www.coursera.org/course/progfun" >Functional Programming in Scala</a>):</p>

<blockquote>
<p>Using <code>forall</code>, implement a function <code>exists</code> which tests whether a set contains at least one element for which the given predicate is true. Note that the functions <code>forall</code> and <code>exists</code> behave like the universal and existential quantifiers of first-order logic.</p>
</blockquote>

<p>The code listing for <code>forall</code> is as follows:</p>

<pre><code>def forall(s: Set, p: Int => Boolean): Boolean = {
  def iter(a: Int): Boolean = {
    if (a > bound) true
    else if (contains(s, a) && !p(a)) false
    else iter(a + 1)
  }
  iter(-bound)
}</code></pre>

<p>where <code>bound</code> is <code>1000</code>.</p>

<p>A set is a defined as follows, along with the predicate to test for containment.</p>

<pre><code>type Set = Int => Boolean
def contains(s: Set, x: Int) = s(x)</code></pre>

<p>Here is how I arrive at the answer for the question:</p>

<blockquote>
<ol>
<li>From the question, it is intuitive to try to stop the iteration when there is an element that satisfies the predicate <code>p</code>, which is exactly what <code>exists</code> should do.</li>
<li>The iteration is stopped only when the current element <code>a</code> does not satisfy <code>p</code>.</li>
<li>However, we need to satisfy <code>p</code> in order for <code>exists</code> to correctly do its job.</li>
</ol>

<p>In conclusion, we need a double negation here. In other words, we need to negate <code>p</code> and then negate the answer returned by <code>forall</code> when called with the negation of <code>p</code>.</p>
</blockquote>

<p>From that reasoning, it is easy to code up the first attempt at a solution.</p>

<pre><code>def exists(s: Set, p: Int => Boolean): Boolean = !forall(s, x => !p(x))</code></pre>

<p>Now, let's see how this solution fares.</p>

<pre><code>scala> def natural = (x: Int) => x > 0
scala> forall(natural, x % 2 == 0) // should return false, as not all naturals are even
Res01 = false
scala> exists(natural, x % 2 == 0) // should return true
Res02 = true</code></pre>

<p>The solution passes the tests. Let's look at how to explain the code simply. The code says</p>

<blockquote>
<p>There exists in set <code>s</code> an element that satisfies the predicate <code>p</code> when not all of the elements in <code>s</code> satisfies the negation of <code>p</code>.</p>
</blockquote>

<p>That makes sense. But lo and behold, the code reflects a mathematical truth, and it even looks like it is translated verbatim from mathematical symbols to programmatical symbols!</p>

<p>&exist;x:P(x) &equiv; &not;&forall;x:&not;P(x)</p>

<p>compared with</p>

<pre><code>def exists(s: Set, p: Int => Boolean): Boolean = !forall(s, x => !p(x))</code></pre>

<p>The correspondence is remarkable!</p>

<p>After reading this post, you should try this question. The answer will pleasantly surprise you.</p>

<blockquote>
<p>Finally, write a function <code>map</code> which transforms a given set into another one by applying to each of its element the given function. <code>map</code> has the following signature:</p>
</blockquote>

<pre><code>def map(s: Set, f: Int => Int): Set</code></pre>
 ]]></description> </item><item> <title>Zen in Gödel, Escher and Bach: An Eternal Golden Braid</title> <link>http://minhdo.org/posts/Zen-in-Gdel-Escher-and-Bach-An-Eternal-Golden-Braid.html</link> <pubDate>2012-09-26 00:00:00</pubDate> <author>Do Nhat Minh</author> <guid isPermaLink="true">http://minhdo.org/posts/Zen-in-Gdel-Escher-and-Bach-An-Eternal-Golden-Braid.html</guid> <category><![CDATA[ excerpt ]]></category><category><![CDATA[ literature ]]></category><category><![CDATA[ philosophy ]]></category><category><![CDATA[ spirituality ]]></category><category><![CDATA[ zen ]]></category> <description><![CDATA[ 

<blockquote>
<p>[...] in general, the Zen attitude is that words and truth are incompatible, or at least that no words can capture truth.</p>
</blockquote>

<p align="right">page 246</p>

<blockquote>
<p>[...] Perhaps the most concise summary of enlightenment would be: trainscending dualism.</p>
</blockquote>

<p align="right">page 251</p>

<blockquote>
<p>[...] it is perhaps wrong to say that the enemy of enlightenment is logic; rather, it is dualistic, verbal thinking. In fact, it is even more basic than that: it is perception. As soon as you perceive an object, you draw a line between it and the rest of the world; you divide the world, artificially, into parts, and you thereby miss the Way.</p>
</blockquote>

<p align="right">page 251</p>

<blockquote>
<p>Zen is holism, carried to its logical extreme. If holism claims that things can only be understood as wholes, not as sums of their parts, Zen goes one further, in maintaining that the world cannot be broken into parts at all. To divide the world into parts is to be deluded, and to miss enlightenment.</p>
</blockquote>

<p align="right">page 254</p>

<blockquote>
<p>Zen is a system and cannot be its own metasystem; there is always something outside of Zen, which cannot be fully understood or described within Zen.</p>
</blockquote>

<p align="right">page 255</p>

<p>Taken from <a href="http://en.wikipedia.org/wiki/G%C3%B6del,_Escher,_Bach" >Gödel, Escher and Bach: An Eternal Golden Braid</a> by <a href="http://en.wikipedia.org/wiki/Douglas_Hofstadter" >Douglas R. Hofstadter</a>.</p>
 ]]></description> </item><item> <title>Setting for NTU MailBox</title> <link>http://minhdo.org/posts/Setting-for-NTU-MailBox.html</link> <pubDate>2012-09-11 00:00:00</pubDate> <author>Do Nhat Minh</author> <guid isPermaLink="true">http://minhdo.org/posts/Setting-for-NTU-MailBox.html</guid> <category><![CDATA[ configuration ]]></category><category><![CDATA[ mailbox ]]></category><category><![CDATA[ ntu ]]></category><category><![CDATA[ setting ]]></category> <description><![CDATA[ <p>External POP setting:</p>

<ul>
<li>Server name: pod51003.outlook.com</li>
<li>Port: 995</li>
<li>Encryption method: SSL</li>
</ul>

<p>External IMAP setting:</p>

<ul>
<li>Server name: pod51003.outlook.com</li>
<li>Port: 993</li>
<li>Encryption method: SSL</li>
</ul>

<p>External SMTP setting:</p>

<ul>
<li>Server name: pod51003.outlook.com</li>
<li>Port: 587</li>
<li>Encryption method: TLS</li>
</ul>

<p>They can be found on the About page of the web app.</p>
 ]]></description> </item> </channel> </rss>
